<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  font: 20px Arial;
}

.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.x.axis path {
  display: none;
}

.line {
  fill: none;
  stroke: "#8D9091";
  stroke-width: 2px;
  opacity: 0.1;
}

.bar {
  fill: #00467F;
}

</style>

<!-- Dark Blue  #00467F -->
<!-- Light Blue #009AC7 -->
<!-- Silver     #8D9091 -->

<body>
  <script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>

  <div class="plots"></div>

<script>
var margin = {top: 20, right: 80, bottom: 50, left: 125}
var width = 800 - margin.left - margin.right
var height = 400 - margin.top - margin.bottom;
var nbins = 8
var maxbarheight = margin.right/2

// X axis
var x = d3.scale.linear().range([0, width]);
var xAxis = d3.svg.axis().scale(x).orient("bottom");

// Y axis
var y = d3.scale.linear().range([height, 0]);
var yAxis = d3.svg.axis().scale(y).orient("left");

// d3 line function
var line = d3.svg.line()
  .interpolate("basis")
  .x(function(d,i) { return x(i+1) })
  .y(function(d,i) { return y(d) });

// This function bins the data at x breakpoints
var histogram = function(x, data) {
  var hist = d3.layout.histogram().frequency(false).bins(x.ticks(nbins));
  return hist(data);
}

function bin_data(simulations, i, ydomain) {
  // x scale (corresponding to y scale of line plot)
  var x = d3.scale.linear().domain(ydomain).range([0, height]);
  var data = simulations.map(function(sim) {return sim[i]});
  // bin the data
  return histogram(x, data);
}

// This function adds all the plots to the page
var runmain = function(data) {
  // d3.json("run.json", function(data) {
    var plots = Array(data.length)
    data.map(function(plotdata, fileindex) {
      var nsimulations = plotdata.data.length
      var nstages = plotdata.data[0].length

      // Create new svg
      var svg = d3.select("body").select(".plots").append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + 1.5*margin.bottom)
          .append("g")
          .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      var  domain=[
        d3.min(plotdata.data, function(sim){return d3.min(sim)}),
        d3.max(plotdata.data, function(sim){return d3.max(sim)})
      ];

      var histdata = []
      for (var i=0;i<nstages;i++) {
        histdata.push(bin_data(plotdata.data, i, domain));
      }

      // set domain of axis
      y.domain(domain);
      x.domain([1, nstages]);

      // add the x axis
      svg.append("g").attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")").call(xAxis);

      // add the y axis
      svg.append("g").attr("class", "y axis").call(yAxis)

      // add all the simulations
      var sim = svg.selectAll(".sim")
        .data(plotdata.data)
        .enter().append("g")
        .attr("class", "sim");

      sim.append("path")
      // name class by simulation index
      .attr("class", function(d,i) {return "line " + i})
      // add the line
      .attr("d", function(d,i) {return line(d,i); })
      .style("stroke", "#8D9091")
      // highlight simulation on mouseover
      .on("mouseover", function(d) {
        // class name
        var classstring = d3.select(this)[0][0].className.baseVal.split(" ");

        // all corresponding simulations from all plots
        elements = document.getElementsByClassName(classstring[1]);

        for (var i = 0; i < elements.length; i++) {
          // change to light blue
          elements[i].style.stroke="#009AC7";
          // change opacity
          elements[i].style.opacity=1;
          // increase width
          elements[i].style["stroke-width"]="3px";
          // bring to front
          elements[i].parentNode.parentNode.appendChild(elements[i].parentNode);
        }
      })
      // restore line on mouse out
      .on("mouseout", function(d) {
        // class name
        var classstring = d3.select(this)[0][0].className.baseVal.split(" ");

        // get all corresponding lines from all plots
        elements = document.getElementsByClassName(classstring[1]);

        for (var i = 0; i < elements.length; i++) {
          // light grey
          elements[i].style.stroke="#8D9091";
          // transparent again
          elements[i].style.opacity=0.1;
          // thin again
          elements[i].style["stroke-width"]="2px";
        }
      }); // end sim.append("path")

      // Add the text label for the x axis
      svg.append("text")
        .attr("transform", "translate(" + (width / 2) + " ," + (height + margin.bottom) + ")")
        .style("text-anchor", "middle").text("Stages");

      // Add the text label for the Y axis
      svg.append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 0 - margin.left)
        .attr("x",0 - (height / 2))
        .attr("dy", "1em")
        .style("text-anchor", "middle")
        .text(plotdata.label);

      // add the vertical line
      svg.append("line")
        .attr("x1", 0).attr("y1", 0)
        .attr("x2", 0).attr("y2", height)
        .attr("class", "vertline")
        .style("stroke-width", 2)
        .style("stroke", "#8D9091")
        .style("fill", "none");

      plots[fileindex] = {svg:svg, domain:domain, file:fileindex, histdata:histdata}
    }); // end data.map

    plots.map(function(plot) {
      add_density(plot)
      var nstages = plot.histdata.length
      plot.svg.on("mousemove", function() {
        // get the x location
        xpos = d3.mouse(this)[0];
        // console.log(x(1), xpos)
        // check its within the x domain
        if (xpos >= x(1) && xpos < x(nstages+1)) {
          // bin to integer weeks
          xact =  Math.round(xpos * (nstages-1) / width) * width / (nstages-1)
          // for all the lines
          var elements = document.getElementsByClassName("vertline");
          for (var i = 0; i < elements.length; i++) {
            elements[i].setAttribute("x1", +xact);
            elements[i].setAttribute("x2", +xact);
          };
          // rebuild histograms in correct place
          plots.map(function(d) {
            updatedensity(d, Math.round(xpos * (nstages-1) / width))
          });
        }
      }); // end plot.svg.on
    }); // end plots.map
  // }); // end d3.json
};  // end runmain

// This function initialises the histograms
function add_density(p) {
    // x scale (corresponding to y scale of line plot)
    var x = d3.scale.linear().domain(p.domain).range([0, height]);

    // height of histogram (width in line plot)
    var y = d3.scale.linear()
      .domain([0, d3.max(p.histdata[p.histdata.length-1], function(d){return d.y})])
      .range([maxbarheight, 0]);

    // add the bars to correct svg
    var barheight = 0.
    var h;
    for (var i=0;i<p.histdata.length;i++) {
      for (var j=0;j<p.histdata[i].length;j++) {
        h = x(p.histdata[i][j].dx + p.histdata[i][j].x) - x(p.histdata[i][j].x)
        if (h > barheight) {
          barheight = h
        }
      }
    }
    p.svg.selectAll(".bar")
      .data(p.histdata[p.histdata.length-1])
      .enter().insert("rect", ".axis")
      // name class by simulation index and filename
      .attr("class", function(d,i) {return "bar chart" + p.file + i})
      // transform to correct location
      .attr("transform", "rotate(180) translate(" + -(width+maxbarheight) + "," + -height + ")")
      // y location of bar
      .attr("y", function(d) { return x(d.x);})
      // x location of bar
      .attr("x", function(d) { return y(d.y); })
      // height of the bars
      .attr("height", barheight)
      // width of the bars
      .attr("width", function(d) { return maxbarheight - y(d.y); });
};

// This function updates the histogram
function updatedensity(plot, column) {
  var nstages = plot.histdata.length

  var x = d3.scale.linear().domain(plot.domain).range([0, height]);
  var histdata = plot.histdata[column];

  // revise scale
  var y = d3.scale.linear()
    .domain([0, d3.max(histdata, function(d){return d.y})])
    .range([maxbarheight, 0]);

  // for each bin
  for (var i = 0; i < histdata.length; i++) {
    elements = document.getElementsByClassName("chart" + plot.file +i);
    if (elements.length > 0) {
      // update x location
      elements[0].setAttribute("x", width * (1 - column/(nstages-1)) + y(histdata[i].y));
      // update y location
      elements[0].setAttribute("y", x(histdata[i].x));
      // update bar width
      elements[0].setAttribute("width", margin.right/2 - y(histdata[i].y));
    }
  }
};

runmain(
  <!--DATA-->
);
</script>

</body>
